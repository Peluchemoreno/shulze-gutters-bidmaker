<!DOCTYPE html>
<html lang="en" id="whole">
  <head>
    <!-- do not change or delete this file, it is for making the password page -->
    <!-- in this version the 'phone' section is in the incorrect position. it should be on its own line -->
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      content="width=device-width"
      initial-scale="1.0"
      maximum-scale="1.0"
      user-scalable="0"
      name="viewport"
    />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="img/icons8-inspection-40.png" type="image/x-icon" />
    <title>Bid Maker</title>
    <!-- <link rel="stylesheet" href="styles.css" /> -->
     <style>
      * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: Arial, Helvetica, sans-serif;
  font-size: 14px;
}

body {
  position: relative;
}

.modal {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.6);
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  height: 100%;
  visibility: hidden;
  opacity: 0;
  transition: opacity .2s ease, visiblity .2s ease;
}

.modal_visible{
  display: flex;
  position: absolute;
  background-color: rgba(0, 0, 0, 0.6);
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  height: 100%;
  justify-content: center;
  align-items: center;
  visibility: visible;
  opacity: 1;
  transition: opacity .2s ease, visiblity .2s ease;
}

.modal__container {
  padding: 20px;
  border: 1px solid black;
  background-color: #414141;
  color: white;
  max-width: 50%;
}

.container__input {
  width: 100%;
  margin-top: 20px;
  color: black;
}

.container__buttons{
  display: flex;
  justify-content: flex-end;
  gap: 20px;
  margin-top: 20px;
}

.container__title {
  font-size: 1.25rem;
}

.button {
  padding: 5px 15px;
  border: none;
  cursor: pointer;
}

.button_confirm {
  background-color: #26e600;
}

.button_cancel {
  background-color: rgb(240, 90, 90);
}

.cancel-button,
.set-button {
  border: none;
  border-radius: 5px;
  padding: 10px;
  font-size: 14px;
  background-color: transparent;
  font-weight: bold;
}

.cancel-button:hover,
.set-button:hover {
  cursor: pointer;
  background-color: rgba(0, 0, 0, 0.6);
}

.selector-button {
  padding: 10px;
  border: none;
  border-bottom: 2px solid black;
  border-radius: 5px;
}

.selector-button:last-of-type {
  border-bottom: 2px solid rgb(126, 126, 126);
}

.selector-button:hover {
  cursor: pointer;
}

.color-preview {
  height: 25px;
  width: 25px;
  background-color: black;
  border-radius: 50%;
  border: 2px solid black;
  transition: background-color 0.5s;
  transition: border 0.5s;
}

.red {
  background-color: red;
}

.cyan {
  background-color: cyan;
}

.blue {
  background-color: blue;
}

.green {
  background-color: #2efc05;
}

.pink {
  background-color: magenta;
}

.yellow {
  background-color: yellow;
}

.black {
  background-color: #000;
  color: #fff;
}

.visible {
  display: grid;
}

#canvas {
  background-size: cover;
  border: 1px solid #000000;
  border-top: none;
  border-left: none;
}

.header-logo {
  width: 300px;
  height: 150px;
  margin-left: 20px;
  padding: 10px;
}

.header-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  height: 140px;
}

.date-container {
  align-self: flex-end;
  padding: 20px;
}

.customer-details-header {
  color: rgb(255, 255, 255);
  background-color: black;
  margin: 0;
  padding: 10px;
  letter-spacing: 3px;
  border: 2px solid black;
}

.customer-details-body {
  display: grid;
  grid-template-columns: 1fr 7fr 1fr 7fr;
  margin-bottom: 0;
}

.customer-details-body2 {
  display: grid;
  grid-template-columns: 1fr 7fr;
  margin-top: 0px !important;
}

#email {
  flex-grow: 1;
  text-align: left;
}

.label {
  width: 100px;
}

select {
  text-align: right;
  border: none;
}

.form-wrapper {
  margin: 0 auto;
  max-width: 820px;
}

.section2 {
  display: flex;
  max-width: 820px;
}

.canvas-side,
.material-side {
  display: inline-block;
}

.material-side {
  border-bottom: 2px solid black;
  border-right: 2px solid black;
}

.canvas-side {
  border-left: 2px solid black;
  border-bottom: 2px solid black;
}

.material-side {
  flex-grow: 1;
}

.material-details-header,
.extra-and-pricing-header,
.job-notes-header {
  text-align: center;
  padding: 5px;
  background-color: black;
  color: white;
  letter-spacing: 3px;
}

.job-notes {
  background-color: black;

  display: block;
  letter-spacing: 3px;
  margin-top: 5px;
}

#job-notes {
  width: 100%;
  padding: 5px;
  font-size: 11px;
  resize: none;
  border-right: none;
  border-bottom: none;
  border-left: 1px solid black;
}

.material-details-body,
.extra-and-pricing-body {
  display: grid;
  grid-template-columns: 1fr 2fr;
}

form {
  padding: 10px;
  width: 100%;
}

label {
  background-color: rgb(65, 65, 65);
  color: rgb(255, 255, 255);

  padding: 5px 10px;
  font-weight: bold;
  letter-spacing: 1px;
  border: 1px solid rgba(0, 0, 0, 0.6);
  min-height: 15px;
}

.material-details-body input,
.extra-and-pricing-body input {
  text-align: right;
  width: 100%;
  font-size: 10px;
  padding: 3px;
}

.material-details-body label,
.extra-and-pricing-body label {
  font-size: 10px;
  font-weight: bolder;
}

label,
input {
  border: none;
  border-bottom: 1px solid black;
  padding: 5px;
}

.tools-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0;
  padding: 0px 5px;
  max-width: 500px;
}

.tools-bar button,
.tools-bar input,
.tools-bar select {
  border-radius: 5px;
  padding: 5px 10px;
  /* background-color: silver; */
  flex-grow: 1;
  margin: auto 3px;
  max-height: 30px;
  font-size: 12px;
  font-weight: 600;
}

.tools-bar select {
  font-weight: 400;
}

#clear-button {
  background-color: rgb(241, 112, 112);
}

#tool-select {
  text-align: left;
  background-color: silver;
  border: none;
  border-radius: 5px;
  width: 70px;
}

#finish-button {
  background: rgb(94, 235, 94);
}

#grid-size {
  max-width: 70px;
}

@media print {
  body {
    print-color-adjust: exact;
    -webkit-print-color-adjust: exact;
  }
}

#additions,
#additions3,
#screen {
  resize: none;
  padding: 1px;
  text-align: right;
  overflow: hidden;
  font-size: 10px;
  scroll-behavior: none;
}

#additions2 {
  resize: none;
  padding: 1px;
  text-align: right;
  overflow: hidden;
  font-size: 10px;
  scroll-behavior: none;
}

#additions-label,
#additions2-label,
#screen-label {
  display: flex;
  align-items: center;
}

#color {
  text-align: center;
  padding: 0;
  height: 25px;
  background-color: silver;
}

.input__section {
  display: grid;
  grid-template-columns: 1fr 1fr;
}

.input__section > input ~ input{
  border: 1px solid black;
  border-top: none;
  border-right: none;
}

.size__header{
  display: grid;
  background-color: rgb(65, 65, 65);
  color: white;
  grid-template-columns: 1fr 1fr 1fr;
  text-align: center;
  border-bottom: 1px solid black;
  padding: 3px 0;
}

.size__header2{

  display: grid;
  background-color: rgb(65, 65, 65);
  color: white;
  grid-template-columns: 1fr 1fr 1fr;
  text-align: center;
  border-bottom: 1px solid black;
  padding: 3px 0;
}

.size__header_section_label{
  font-size: 12px;
  font-weight: bold;
  text-align: left;
  padding-left: 5px;
}
.size__header_section_label2{
  width: 95px;
  font-size: 12px;
  font-weight: bold;
  text-align: left;
  padding-left: 5px;
}

.size__header_section2{
  text-align: center;
}

.offset-input{
  height: 27px;
}

.undo-button {
  /* display: none; */
  background-color: #d9f170;
}

.toolbar__number-input{
  /* display: none; */
  background-color: silver;
}

.eraser-btn {
  background-color: silver;
  transition: background-color .2s ease;
}

.eraser-btn_on {
  background-color: pink;
}

button {
  cursor: pointer;
}
     </style>
  </head>

  <body>
    <div class="modal">
      <div class="modal__container">
        <h2 class="container__title">
          Type in the elbow sequence or the length of the piece. (ex: AABA,
          57")
        </h2>
        <input id="textinput" type="text" class="container__input" />
        <div class="container__buttons">
          <button type="button" class="button button_cancel">Cancel</button>
          <button type="button" class="button button_confirm">OK</button>
        </div>
      </div>
    </div>
    <div class="form-wrapper">
      <form>
        <div class="header-container">
          <img
            class="header-logo"
            src="./img/SGS-logo.png"
            alt="schulze gutter services logo"
          />
          <div class="date-container">
            <label for="date">Install Date:</label>
            <input id="date" class="input form-field" type="date" />
          </div>
        </div>
        <div class="customer-details-container">
          <div class="customer-details-header">
            <h2>CUSTOMER DETAILS</h2>
          </div>
          <div class="customer-details-body">
            <label class="label" for="name">Name:</label>
            <input
              id="name"
              name="name"
              type="text"
              maxlength="100"
              minlength="1"
            />

            <label class="label" for="phone">Phone:</label>
            <input type="text" name="phone" id="phone" />
          </div>
          <div class="customer-details-body2">
            <label class="label" for="address">Address:</label>
            <input type="text" name="address" id="address" />

            <label class="label" for="email">Email:</label>
            <input type="email" name="email" id="email" />
          </div>
        </div>

        <div class="section2">
          <div class="canvas-side">
            <canvas id="canvas"></canvas>
            <div class="tools-bar">
              <select id="tool-select">
                <option value="gutter">Gutter</option>
                <!-- <option value="gutter-w-screen">Gutter w/ Screen</option> -->
                <option value="existing-gutter">Existing Gutter</option>
                <option value="downspout">Downspout</option>
                <option value="drop">Drop to lower</option>
                <option value="valley-shield">Valley Shield</option>
                <option value="free-text">Elbow Seq/Piece Length</option>
                <!-- <option value="eraser">Eraser</option> -->
                <!-- <option value="flashing">Flashing</option>
              <option value="fascia-repair">Fascia Repair/Replace</option> -->
              </select>
              <input
                type="number"
                min="10"
                max="50"
                id="grid-size"
                value="14"
                class="toolbar__number-input"
              />
              <!-- <button id="color">Color</button> -->
              <button type="button" class="undo-button">Set Grid</button>
              <select id="color">
                <option
                  value="black"
                  style="background-color: black; color: white"
                >
                  Black
                </option>
                <option value="red" style="background-color: red; color: white">
                  Red
                </option>
                <option
                  value="cyan"
                  style="background-color: cyan; color: black"
                >
                  Cyan
                </option>
                <option
                  value="blue"
                  style="background-color: blue; color: white"
                >
                  Blue
                </option>
                <option
                  value="green"
                  style="background-color: #2efc05; color: black"
                >
                  Green
                </option>
                <option
                  value="magenta"
                  style="background-color: magenta; color: black"
                >
                  Magenta
                </option>
                <option value="yellow" style="background-color: yellow">
                  Yellow
                </option>
              </select>

              <button class="eraser-btn" type="button">Eraser</button>
              <button type="button" id="clear-button">Clear</button>
              <button type="button" id="finish-button" onclick="finish()">
                Done
              </button>
            </div>
            <label for="job-notes" class="job-notes">
              JOB DESCRIPTION / NOTES
            </label>
            <textarea
              name="job-description"
              id="job-notes"
              rows="10"
            ></textarea>
          </div>
          <div class="material-side">
            <div class="material-details">
              <div class="material-details-header">
                <h3>MATERIAL</h3>
              </div>
              <div class="size__header">
                <div class="size__header_section_label">Size</div>
                <div class="size__header_section">5"</div>
                <div class="size__header_section">6"</div>
              </div>
              <div class="material-details-body">
                <label for="coil-color" class="coil-color">Coil Color</label>
                <div class="input__section">
                  <input type="text" name="coil-color" id="coil-color" />
                  <input type="text" name="coil-color" id="coil-color" />
                </div>

                <label for="coil-footage" class="coil-footage"
                  >Coil Qty (Lbs)</label
                >
                <div class="input__section">
                  <input
                    type="text"
                    min="0"
                    max="99999"
                    name="coil-footage"
                    id="coil-footage"
                  />
                  <input
                    type="text"
                    min="0"
                    max="99999"
                    name="coil-footage"
                    id="coil-footage1"
                  />
                </div>

                <label for="downspout-color" class="downspout-color"
                  >Left End Caps</label
                >
                <div class="input__section">
                  <input type="text" name="color" id="downspout-color" />
                  <input type="text" name="color" id="downspout-color" />
                </div>

                <label for="ds-footage" class="ds-footage"
                  >Right End Caps</label
                >
                <div class="input__section">
                  <input
                    type="text"
                    min="0"
                    max="99999"
                    name="ds-footage"
                    id="ds-footage"
                  />
                  <input
                    type="text"
                    min="0"
                    max="99999"
                    name="ds-footage"
                    id="ds-footage"
                  />
                </div>

                <label for="splash-guards" class="splashBlocks"
                  >Outside Miters</label
                >
                <div class="input__section">
                  <input type="text" name="splash-guards" id="splash-guards" />
                  <input type="text" name="splash-guards" id="splash-guards" />
                </div>

                <label for="ism" class="ism">Inside Miters</label>
                <div class="input__section">
                  <input type="text" min="0" max="99999" name="ism" id="ism" />
                  <input type="text" min="0" max="99999" name="ism" id="ism" />
                </div>

                <label for="osm" class="osm">Outside Bay Miters</label>
                <div class="input__section">
                  <input type="text" min="0" max="99999" name="osm" id="osm" />
                  <input type="text" min="0" max="99999" name="osm" id="osm" />
                </div>

                <label for="custom-miters" class="custom-miters"
                  >Inside Bay Miters</label
                >
                <div class="input__section">
                  <input
                    type="text"
                    min="0"
                    max="99999"
                    name="custom-miters"
                    id="custom-miters"
                  />
                  <input
                    type="text"
                    min="0"
                    max="99999"
                    name="custom-miters"
                    id="custom-miters"
                  />
                </div>
              </div>
              <div class="extra-and-pricing-header">
                <h3>DOWNSPOUT</h3>
              </div>
              <div class="size__header2">
                <div class="size__header_section_label2">Size</div>
                <div class="size__header_section2">2x3</div>
                <div class="size__header_section2">3x4</div>
              </div>
            </div>
            <div class="pricing-container">
              <div class="extra-and-pricing-body">
          

                <label for="b-elbows">Downspout Qty</label>
                <div class="input__section">
                  <input
                    min="0"
                    max="99999"
                    type="text"
                    name="b-elbows"
                    id="b-elbows"
                  />
                  <input
                    min="0"
                    max="99999"
                    type="text"
                    name="b-elbows"
                    id="b-elbows"
                  />
                </div>

                <label for="offsets">As</label>
                <div class="input__section">
                  <input
                    min="0"
                    max="99999"
                    type="text"
                    name="offsets"
                    id="offsets"
                  />
                  <input
                    min="0"
                    max="99999"
                    type="text"
                    name="offsets"
                    id="offsets"
                  />
                </div>

                <label for="splash-blocks">Bs</label>
                <div class="input__section">
                  <input
                    min="0"
                    max="99999"
                    type="text"
                    name="splash-blocks"
                    id="splash-blocks"
                  />
                  <input
                    min="0"
                    max="99999"
                    type="text"
                    name="splash-blocks"
                    id="splash-blocks"
                  />
                </div>

                <label for="screen" id="screen-label"
                  >Offset(s)-(Qty), Size</label
                >
                <div class="input__section">
                  <!-- <textarea id="screen" rows="6"></textarea> -->
                  <input class="offset-input" type="text">
                  <input class="offset-input" type="text">
                  <input class="offset-input" type="text">
                  <input class="offset-input" type="text">
                  <input class="offset-input" type="text">
                  <input class="offset-input" type="text">
                </div>

                <label for="drip-edge">Zip Screws</label>
                <input
                  min="0"
                  max="99999"
                  type="text"
                  name="drip-edge"
                  id="drip-edge"
                />

                <label for="other">Straps/Wedges</label>
                <input type="text" name="other" id="other" />

                <label for="additions3" id="additions3-label"
                  >Small Hole Black Mesh</label
                >
                <div class="input__section">
                  <input type="text" name="additions3" id="additions3" />
                  <input type="text" name="additions3" id="additions3" />
                </div>

                <label for="additions" id="additions2-label"
                  >LeafBlaster Pro</label
                >
                <div class="input__section">
                  <input type="text" name="additons2" id="additions"></input>
                  <input type="text" name="additons2" id="additions"></input>
                </div>

                <label for="additions2" id="additions-label"
                  >Concrete Splash Blocks</label
                >
                <!-- <textarea rows="4" id="additions2"></textarea> -->
                 <input type="text" name="additions2" id="additions2">

                <label for="total">Grand Total:</label>
                <input type="text" name="total" id="total" placeholder="$" />
              </div>
            </div>
          </div>
        </div>
      </form>
    </div>

    <!-- <script src="scripts.js"></script> -->
     <script>
      const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const undoBtn = document.querySelector(".undo-button");
const clearButton = document.querySelector("#clear-button");
const colorPicker = document.querySelector("#color");
const gridSizeInput = document.querySelector("#grid-size");
const tool = document.querySelector("#tool-select");
const textInputEl = document.querySelector(".container__input");
const cancelBtn = document.querySelector(".button_cancel");
const confirmBtn = document.querySelector(".button_confirm");
const modal = document.querySelector(".modal");
const eraserBtn = document.querySelector(".eraser-btn");

let isDrawing = false;
let startX, startY, currentX, currentY;
let lines = []; // Store start and end coordinates for lines
let index = -1;
let rubberLinePath = null;
let history = []; // History to store previous states of the canvas
let isEraserOn = false;

// Initialize Canvas
function startup() {
  canvas.width = 500;
  canvas.height = 500;
  drawGrid();
  updateUndoButton();
}

// Draw the grid on the canvas
function drawGrid() {
  ctx.setLineDash([]);
  const gridSize = parseInt(gridSizeInput.value);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "lightgray";
  for (let x = 0; x < canvas.width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
}

// Snap coordinates to the nearest grid point
function snapToGrid(value) {
  const gridSize = parseInt(gridSizeInput.value);
  return Math.round(value / gridSize) * gridSize;
}

// Get coordinates from event (supports both mouse and touch)
function getCoordinates(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.touches ? event.touches[0].clientX : event.clientX;
  const y = event.touches ? event.touches[0].clientY : event.clientY;
  return {
    x: snapToGrid(x - rect.left),
    y: snapToGrid(y - rect.top),
  };
}

// Update the color based on user selection
function updateColor() {
  ctx.strokeStyle = colorPicker.value;
  ctx.fillStyle = colorPicker.value;
}

// Start drawing
function startDrawing(event) {
  isDrawing = true;
  const { x, y } = getCoordinates(event);
  startX = x;
  startY = y;
  ctx.lineWidth = 2;
  updateColor();
  if (isEraserOn === true) {
    eraseNearestLine();
    return;
  }

  if (tool.value === "gutter") {
    ctx.moveTo(x, y);
    ctx.setLineDash([]);
  } else if (tool.value === "existing-gutter") {
    ctx.setLineDash([2, 2]);
  } else if (tool.value === "downspout" || tool.value === "drop") {
    ctx.setLineDash([]);
  }
}

// Draw a rubber line (for both drawing and erasing)
function drawRubberLine(event) {
  if (
    !isDrawing ||
    tool.value === "downspout" ||
    tool.value === "free-text" ||
    tool.value === "drop" ||
    tool.value === "valley-shield" ||
    isEraserOn === true
  )
    return;

  const { x, y } = getCoordinates(event);
  currentX = x;
  currentY = y;

  if (rubberLinePath) {
    ctx.putImageData(rubberLinePath, 0, 0); // Clear temporary line
  } else {
    rubberLinePath = ctx.getImageData(0, 0, canvas.width, canvas.height);
  }

  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(currentX, currentY);
  ctx.lineWidth = 2;
  ctx.stroke();
}

// Finalize the line on pointer up
function stopDrawing(event) {
  if (isDrawing) {
    isDrawing = false;
    rubberLinePath = null; // Clear rubber band

    if (isEraserOn === true) {
      eraseNearestLine();
      return;
    }

    if (tool.value === "downspout") {
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(
        startX + gridSizeInput.value / 2.75,
        startY + gridSizeInput.value / 2.75
      );
      ctx.moveTo(startX, startY);
      ctx.lineTo(
        startX - gridSizeInput.value / 2.75,
        startY + gridSizeInput.value / 2.75
      );
      ctx.moveTo(startX, startY);
      ctx.lineTo(
        startX - gridSizeInput.value / 2.75,
        startY - gridSizeInput.value / 2.75
      );
      ctx.moveTo(startX, startY);
      ctx.lineTo(
        startX + gridSizeInput.value / 2.75,
        startY - gridSizeInput.value / 2.75
      );
      ctx.stroke();
      // Add line coordinates instead of ImageData
      lines.push({
        startX,
        startY,
        endX: startX,
        endY: startY,
        tool: tool.value,
        color: colorPicker.value,
      });
      updateUndoButton();
    } else if (tool.value === "drop") {
      ctx.beginPath();
      ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
      ctx.stroke();
      // Add line coordinates instead of ImageData
      lines.push({
        startX,
        startY,
        endX: startX,
        endY: startY,
        tool: tool.value,
        color: colorPicker.value,
      });
      updateUndoButton();
    } else if (tool.value === "valley-shield") {
      ctx.beginPath();
      ctx.arc(startX, startY, gridSizeInput.value / 4, 0, 2 * Math.PI);
      ctx.fill();
      // Add line coordinates instead of ImageData
      lines.push({
        startX,
        startY,
        endX: startX,
        endY: startY,
        tool: tool.value,
        color: colorPicker.value,
      });
      updateUndoButton();
    } else if (tool.value === "free-text") {
      if (isEraserOn === true) {
        return;
      } else {
        modal.classList.add("modal_visible");
      }
    } else {
      ctx.beginPath();
      // ctx.moveTo(startX, startY);
      ctx.lineTo(currentX, currentY);
      ctx.lineWidth = 2;
      if (!currentX || !currentY) {
        return;
      }
      if (startX === currentX && startY === currentY) {
        return;
      }
      ctx.stroke();
      // Add line coordinates instead of ImageData
      lines.push({
        startX,
        startY,
        endX: currentX,
        endY: currentY,
        tool: tool.value,
        color: colorPicker.value,
      });
      updateUndoButton();
      currentX = null;
      currentY = null;
    }
    if (tool.value !== "free-text") {
      saveState();
    }
  }
}

function placeText(x, y) {
  const userInput = textInputEl.value;
  ctx.font = "1000 12px Arial";
  ctx.fillStyle = "black";
  ctx.textAlign = "center";
  if (!userInput) {
    return;
  } else {
    ctx.fillText(`${userInput}`, x, y);
    lines.push({
      startX,
      startY,
      endX: startX,
      endY: startY,
      tool: tool.value,
      content: userInput,
      color: colorPicker.value,
    });
    saveState();
  }
  textInputEl.value = "";
  modal.classList.remove("modal_visible");
}

function eraseNearestLine() {
  const tolerance = 10; // Tolerance in pixels for erasing (you can adjust this)

  // Loop through the stored lines and check if they intersect with the eraser area
  for (let i = lines.length - 1; i >= 0; i--) {
    let line = lines[i];

    // Check if the line is within the eraser's tolerance
    if (
      isLineCloseToCursor(
        line.startX,
        line.startY,
        line.endX,
        line.endY,
        startX,
        startY,
        tolerance
      )
    ) {
      lines.splice(i, 1); // Remove the line from lines
      redrawCanvas(); // Redraw canvas with updated lines
      break;
    }
    if (
      line.tool === "downspout" ||
      line.tool === "drop" ||
      line.tool === "valley-shield" ||
      line.tool === "free-text"
    ) {
      if (
        distanceToPoint(line.startX, line.startY, startX, startY) < tolerance
      ) {
        lines.splice(i, 1); // Remove the line from lines
        redrawCanvas(); // Redraw canvas with updated lines
        break;
      }
    }
  }
  updateUndoButton(); // Keep track of the undo stack after erasing a line
}

function isLineCloseToCursor(x1, y1, x2, y2, mouseX, mouseY, radius) {
  // Calculate the perpendicular distance from the mouse to the line
  const distance = pointToLineDistance(x1, y1, x2, y2, mouseX, mouseY);

  // Check if the mouse is within the radius of the line
  if (distance <= radius) {
    // Check if the perpendicular projection falls within the segment bounds
    const projection = projectPointOntoLine(x1, y1, x2, y2, mouseX, mouseY);
    const px = projection.x;
    const py = projection.y;

    // Check if the projected point is on the segment (within bounds of the endpoints)
    const dot1 = (px - x1) * (x2 - x1) + (py - y1) * (y2 - y1); // Dot product to check if projection is within the segment
    const dot2 = (px - x2) * (x1 - x2) + (py - y2) * (y1 - y2); // Dot product for the other side

    if (dot1 >= 0 && dot2 >= 0) {
      return true;
    }
  }

  // If the perpendicular projection doesn't fall on the segment, check distance to the endpoints
  const distToEnd1 = distanceToPoint(mouseX, mouseY, x1, y1);
  const distToEnd2 = distanceToPoint(mouseX, mouseY, x2, y2);

  return distToEnd1 <= radius || distToEnd2 <= radius;
}

// Function to calculate the perpendicular distance from a point to a line
function pointToLineDistance(x1, y1, x2, y2, px, py) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;

  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  const param = lenSq === 0 ? -1 : dot / lenSq;

  let closestX, closestY;

  if (param < 0) {
    closestX = x1;
    closestY = y1;
  } else if (param > 1) {
    closestX = x2;
    closestY = y2;
  } else {
    closestX = x1 + param * C;
    closestY = y1 + param * D;
  }

  const dx = px - closestX;
  const dy = py - closestY;

  return Math.sqrt(dx * dx + dy * dy);
}

function distanceToPoint(x1, y1, x2, y2) {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

function projectPointOntoLine(x1, y1, x2, y2, px, py) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
  const closestX = x1 + t * dx;
  const closestY = y1 + t * dy;

  return { x: closestX, y: closestY };
}

// Redraw the entire canvas based on stored lines
function redrawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setLineDash([]);
  drawGrid();
  updateColor();
  lines.forEach((line) => {
    ctx.strokeStyle = line.color;
    ctx.fillStyle = line.color;
    if (line.tool === "downspout") {
      ctx.beginPath();
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(
        line.startX + gridSizeInput.value / 2.75,
        line.startY + gridSizeInput.value / 2.75
      );
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(
        line.startX - gridSizeInput.value / 2.75,
        line.startY + gridSizeInput.value / 2.75
      );
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(
        line.startX - gridSizeInput.value / 2.75,
        line.startY - gridSizeInput.value / 2.75
      );
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(
        line.startX + gridSizeInput.value / 2.75,
        line.startY - gridSizeInput.value / 2.75
      );
      ctx.setLineDash([]);
      ctx.stroke();
    } else if (line.tool === "drop") {
      ctx.beginPath();
      ctx.arc(
        line.startX,
        line.startY,
        gridSizeInput.value / 4,
        0,
        2 * Math.PI
      );
      ctx.setLineDash([]);
      ctx.stroke();
    } else if (line.tool === "valley-shield") {
      ctx.beginPath();
      ctx.arc(
        line.startX,
        line.startY,
        gridSizeInput.value / 4,
        0,
        2 * Math.PI
      );
      ctx.setLineDash([]);
      ctx.fill();
    } else if (line.tool === "existing-gutter") {
      ctx.beginPath();
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(line.endX, line.endY);
      ctx.lineWidth = 2;
      ctx.setLineDash([2, 2]);
      ctx.stroke();
    } else if (line.tool === "free-text") {
      ctx.font = "1000 12px Arial";
      ctx.fillStyle = "black";
      ctx.textAlign = "center";
      ctx.fillText(line.content, line.startX, line.startY);
    } else {
      ctx.beginPath();
      ctx.moveTo(line.startX, line.startY);
      ctx.lineTo(line.endX, line.endY);
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      ctx.stroke();
    }
  });
}

// Undo the last action
undoBtn.addEventListener("click", () => {
  undo();
});

function undo() {
  // debugger;
  if (history.length > 0) {
    // Pop the last saved state and restore the lines array
    history.pop();
    lines = history[history.length - 1];
    redrawCanvas(); // Redraw canvas with the previous state
    updateUndoButton(); // Update undo button state
  } else {
    clearCanvas(); // If no history, clear the canvas
  }
  updateUndoButton();
}

function saveState() {
  history.push([...lines]); // Copy the current lines array to preserve the state
}

// Clear the canvas
function clearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  lines = []; // Clear current lines
  history = []; // Clear history
  index = -1; // Reset the index (this is unnecessary)
  updateUndoButton(); // Update the undo button state
}

clearButton.addEventListener("click", clearCanvas);

// Update the undo button
function updateUndoButton() {
  if (lines && history) {
    // undoBtn.innerText =
    //   lines.length > 0 && history.length > 0 ? "Undo" : "Set Grid";
    // undoBtn.style.backgroundColor =
    //   lines.length > 0 && history.length > 0 ? "silver" : "#d9f170";
    if (lines.length > 0 && history.length > 0) {
      undoBtn.style.display = "none";
      gridSizeInput.style.display = "none";
    } else if (lines.length === 0) {
      undoBtn.style.display = "inline-block";
      gridSizeInput.style.display = "inline-block";
    }
  } else {
    return;
  }
}

function toggleEraser(status) {
  eraserBtn.classList.toggle("eraser-btn_on");
  isEraserOn = !status;
}

// Add event listeners
canvas.addEventListener("pointerdown", startDrawing);
canvas.addEventListener("pointermove", drawRubberLine);
canvas.addEventListener("pointerup", () => {
  stopDrawing();
  updateUndoButton();
});
canvas.addEventListener("pointerout", stopDrawing);

cancelBtn.addEventListener("click", () => {
  modal.classList.remove("modal_visible");
  textInputEl.value = "";
});

confirmBtn.addEventListener("click", () => {
  placeText(startX, startY);
});

// Add touch events for mobile and tablets
canvas.addEventListener("touchstart", (event) => {
  event.preventDefault();
  startDrawing(event);
});
canvas.addEventListener("touchmove", (event) => {
  event.preventDefault();
  drawRubberLine(event);
});
canvas.addEventListener("touchend", (event) => {
  event.preventDefault();
  stopDrawing();
  updateUndoButton();
});
canvas.addEventListener("touchcancel", stopDrawing);

eraserBtn.addEventListener("click", () => {
  toggleEraser(isEraserOn);
});

// Initialize on DOMContentLoaded
document.addEventListener("DOMContentLoaded", startup);
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    undo();
  }
});

function finish() {
  window.onbeforeprint = (event) => {
    toolsBar = document.querySelector(".tools-bar");
    toolsBar.style.display = "none";
    legendPic = document.querySelector(".legend-pic");
  };
  window.print();
}

window.onafterprint = (event) => {
  toolsBar = document.querySelector(".tools-bar");
  toolsBar.style.display = "flex";
};

     </script>
  </body>
</html>
